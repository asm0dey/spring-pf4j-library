/*
 * This file is generated by jOOQ.
 */
package generated.jooq


import java.util.Optional

import javax.annotation.processing.Generated

import kotlin.collections.Collection
import kotlin.collections.List

import org.jooq.Configuration
import org.jooq.Field
import org.jooq.Table
import org.jooq.UpdatableRecord
import org.jooq.impl.DAOImpl
import org.springframework.transaction.annotation.Transactional


/**
 * Spring specific {@link DAOImpl} override.
 */
@Generated(
    value = [
        "https://www.jooq.org",
        "jOOQ version:3.19.16"
    ],
    comments = "This class is generated by jOOQ"
)
@Suppress("UNCHECKED_CAST")
@Transactional(readOnly = true)
abstract class AbstractSpringDAOImpl<R : UpdatableRecord<R>, P : Any, T>(table: Table<R>, type: Class<P>, configuration: Configuration?) : DAOImpl<R, P, T>(table, type, configuration) {

    constructor(table: Table<R>, type: Class<P>) : this(table, type, null)

    @Transactional(readOnly = true)
    public override fun count(): Long = super.count()

    @Transactional(readOnly = true)
    public override fun exists(obj: P): Boolean = super.exists(obj)

    @Transactional(readOnly = true)
    public override fun existsById(id: T): Boolean = super.existsById(id)

    @Transactional(readOnly = true)
    public override fun <Z> fetch(field: Field<Z>, values: Collection<Z>): List<P> = super.fetch(field, values)

    @Transactional(readOnly = true)
    public override fun <Z> fetch(field: Field<Z>, vararg values: Z): List<P> = super.fetch(field, *values)

    @Transactional(readOnly = true)
    public override fun <Z> fetchOne(field: Field<Z>, value: Z): P? = super.fetchOne(field, value)

    @Transactional(readOnly = true)
    public override fun <Z> fetchOptional(field: Field<Z>, value: Z): Optional<P> = super.fetchOptional(field, value)

    @Transactional(readOnly = true)
    public override fun <Z> fetchRange(field: Field<Z>, lowerInclusive: Z, upperInclusive: Z): List<P> = super.fetchRange(field, lowerInclusive, upperInclusive)

    @Transactional(readOnly = true)
    public override fun findAll(): List<P> = super.findAll()

    @Transactional(readOnly = true)
    public override fun findById(id: T): P? = super.findById(id)

    @Transactional(readOnly = true)
    public override fun findOptionalById(id: T): Optional<P> = super.findOptionalById(id)

    @Transactional
    public override fun insert(obj: P): Unit = super.insert(obj)

    @Transactional
    public override fun insert(vararg objs: P): Unit = super.insert(*objs)

    @Transactional
    public override fun insert(objs: Collection<P>): Unit = super.insert(objs)

    @Transactional
    public override fun update(obj: P): Unit = super.update(obj)

    @Transactional
    public override fun update(vararg objs: P): Unit = super.update(*objs)

    @Transactional
    public override fun update(objs: Collection<P>): Unit = super.update(objs)

    @Transactional
    public override fun merge(obj: P): Unit = super.merge(obj)

    @Transactional
    public override fun merge(vararg objs: P): Unit = super.merge(*objs)

    @Transactional
    public override fun merge(objs: Collection<P>): Unit = super.merge(objs)

    @Transactional
    public override fun delete(obj: P): Unit = super.delete(obj)

    @Transactional
    public override fun delete(vararg objs: P): Unit = super.delete(*objs)

    @Transactional
    public override fun delete(objs: Collection<P>): Unit = super.delete(objs)

    @Transactional
    public override fun deleteById(id: T): Unit = super.deleteById(id)

    @Transactional
    public override fun deleteById(vararg ids: T): Unit = super.deleteById(*ids)

    @Transactional
    public override fun deleteById(ids: Collection<T>): Unit = super.deleteById(ids)
}
